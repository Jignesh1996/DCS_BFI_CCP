% Checking the upsampling factor for the interp and interp1 functions, if
% it is linear or not
y = interp(dcs_1,50);
x = 1:length(y);
x_d = (1:length(dcs_1));
[pks_u,locs_u] = findpeaks(y, 'MinPeakHeight', 0.5,'MinPeakDist',600,'MinPeakProminence',0.1);  %Determine peaks and Indices
figure()
[pks_d,locs_d] = findpeaks(dcs_1, 'MinPeakHeight', 0.5,'MinPeakProminence',10);
[pks_u1,locs_u1] = findpeaks(dcs_1up, 'MinPeakHeight', 0.5,'MinPeakDist',600,'MinPeakProminence',0.1);
a = locs_u./locs_d;
b = locs_u1./locs_d;
plot(x_d,dcs_1)
hold on
plot(x_d(locs_d),pks_d, '+r')
hold off

%% 
dcs_1res = resample(dcs_1,50,1)
plot(dcs_1res)
hold on
plot(dcs_1up)

%%
xu = (1:1:length(ecg1))/1000;
xd = (1:1:length(dcs_1))/20;

%%
ecg_res = resample(ecg1,1,50)
te = (1:1:length(ecg_res));
plot(xd,ecg_res,'b')
legend("Resampled","Original")
hold on
plot(xu, ecg1,'r')
%%
ini = dcs_1(locs_d(1):locs_d(2));
cyc =zeros(length(pks)-1,length(ini)); 
cyc(1,:)= ini;
x = (1:1:length(ini))/1000;
count = 0;
avg = ini;
for i=1:1:length(locs_d)-1
    count = count+1;
 
    sig = dcs_1(find(xd==round(xu(locs(i)),1)):find(xd==round(xu(locs(i+1)),1)));
    hold on;
    if length(avg) > length(sig)
        sig(length(sig):length(avg)) = 0;
    elseif length(avg)< length(sig)
        sig = sig(1:length(avg));
    end
    avg = avg+sig;
    plot((1:length(sig))/20,sig, 'DisplayName',""+i+"");
%     legend show
    cyc(count,:) = sig;
        
end
xlabel("Time(s)")
ylabel("aDb value")
title("Marker=ECG R peak, DCS 1cm Baseline Forearm")
hold off
avg = avg/count;

figure()
plot(x,avg)

%Plotting the ensemble average
ensavg = mean(cyc,1);                                                   % Calculate Ensemble Average
ci95 = 1.96*std(cyc,[],1)/sqrt(count);                             % Calculate 95% Confidence Intervals         
figure()
plot(x, ensavg, '-r', 'LineWidth',1)
hold on;
plot(x, ensavg+ci95, ':g', 'LineWidth',1.5)
plot(x, ensavg-ci95, ':g', 'LineWidth',1.5)
hold off
grid
legend('Ensemble Average', '95% Confidence Intervals')

%%resampling

%%

figure()
hold on
plot(xd,dcs_1/max(dcs_1),'r')
plot(xd,ecg_res/max(ecg),'b')

%% Alligning the peaks of the DCS signal
% The idea is to coincide all the cycles by shifting the peaks to coincide
% with eachother to remove the temporal shift.
Extract=ones(size(pks_ECG_smooth,2)-1,min(diff(locs_ECG_smooth)));
Extract=Extract*NaN;

dcs_1_smooth2=circshift(dcs_1_smooth,shift)

for i=1:size(pks_ECG_smooth,2)-1
    locs_ECG_smooth(i)
    locs_ECG_smooth(i)+min(diff(locs_ECG_smooth))
    signal = dcs_1_smooth2(1,locs_ECG_smooth(i):locs_ECG_smooth(i)+min(diff(locs_ECG_smooth))-1);
    base_sig = dcs_1_smooth2(1,locs_ECG_smooth(1):locs_ECG_smooth(1)+min(diff(locs_ECG_smooth))-1);
    sig = signal + (max(base_sig) - max(signal));
    [pks_b,locs_b] = findpeaks(base_sig, 'MinPeakHeight',0.2);
    [pks_s,locs_s] = findpeaks(sig, 'MinPeakHeight',0.2);
%     if locs_b>=locs_s
%         sig = shi%%%%%%%% Start from here. Subtract the difference betweent base signal location from the current signal
   
    if i==5
        break;
    end
    
%     Extract(i,:)=dcs_1_smooth2(1,locs_ECG_smooth(i):locs_ECG_smooth(i)+min(diff(locs_ECG_smooth))-1);

    Extract(i,:)=sig;
end

%%
bp = 1:100:length(dcs_1lp);
dcs_d = detrend(normalize(dcs_1lp),1,bp);
plot(normalize(dcs_1lp));
hold on;
plot(dcs_d);

%% Signal reconstruction using harmonics
step = 50;
final = zeros(1,step);
for i=1:step
    final = final + squeeze(Data(i+800,4,:));
end
final = final/step;
plot(final)

%%
Fs = 1000;            % Sampling frequency                    
T = 1/Fs;             % Sampling period    
signal = ecg1;
L = length(signal);             % Length of signal
t = (0:L-1)*T;  

Y = fft(signal);
P2 = abs(Y/L);
P1 = P2(1:L/2+1);
P1(2:end-1) = 2*P1(2:end-1);

% calculating the inverse fft to get the amplitude of the signal



f = Fs*(0:(L/2))/L;
figure()
plot(f,P1) 
hold on;
title('Single-Sided Amplitude Spectrum of X(t)')
xlabel('f (Hz)')
ylabel('|P1(f)|')

m = max(P1(100:length(P1)));


[p_hr,l_hr] = findpeaks(P1(100:length(P1)), "MinPeakHeight", m-0.01);
l_hr = l_hr + 98;
f_hr = Fs*(l_hr)/(L);
scatter(f_hr,p_hr);
hold off;

y = Y;
a = abs(ifft(y,40960));
figure();
plot(1:1:length(a),normalize(a))
% figure();
hold on;
plot(1:1:length(a),ecg1(1:length(a)))

%%
sig = [bp_a;tcd];
amp = zeros(1,size(sig,1));
for i=1:size(sig,1)
    signal = sig(i,:);
    L = length(signal);             % Length of signal
    t = (0:L-1)*T;  
    
    Y = fft(signal);
    P2 = abs(Y/L);
    P1 = P2(1:L/2+1);
    P1(2:end-1) = 2*P1(2:end-1);
    figure();
    f = Fs*(0:(L/2))/L;
    plot(f,P1) 
    hold on;
    title('Single-Sided Amplitude Spectrum of X(t)')
    xlabel('f (Hz)')
    ylabel('|P1(f)|')
    
    amp(i) = sum(P1(10:l_hr+50));
    
    % m = max(P1(100:length(P1)));
    % 
    % [p_sig,l_sig] = findpeaks(P1(100:length(P1)), "MinPeakHeight", m-0.01);
    % f_sig = Fs*(l_sig+98)/(L);
    % scatter(f_sig,p_sig);
    
    
    y = Y(1:l_hr+150);
    % y = Y;
    a = abs(ifft(y,4096));
    figure();
    plot(a)

end

%%

t_bp = 0:(2*pi*l_bp)/794:2*pi*l_bp;
sin_bp = p_ecg*sin(t_bp);
plot(t_bp,sin_bp);
hold on;
t_sig = 0:(2*pi*l_sig)/794:2*pi*l_sig;
sin_sig = p_sig*sin(t_sig);
plot(t_sig,sin_sig);

figure();
plot(sin_sig,sin_bp)

%%
pBP =  (max(bp_a)+ 2*min(bp_a))/3;  % MAP pressure
psig = mean(signal);   % mean value of signal

CrCP = pBP - (psig/p_sig)*p_ecg;


%% Averaging g2 curves to improve the SNR

g2_1_temp=squeeze(Data(:,1,:)-1); %g2-1 curve generation
g2_2_temp=squeeze(Data(:,2,:)-1); %g2-1 curve generation
g2_3_temp=squeeze(Data(:,3,:)-1); %g2-1 curve generation
g2_4_temp=squeeze(Data(:,4,:)-1); %g2-1 curve generation

% average g2 curve for 4 channels
g2(1,:,:)=(g2_1_temp);
g2(2,:,:)=(g2_2_temp);
g2(3,:,:)=(g2_3_temp);
g2(4,:,:)=(g2_4_temp);

 

dcs = squeeze(g2(1,:,:));
ecg1 = ecg_a;
ecg1 = normalize(ecg1);
if length(dcs)<length(ecg1)  % shifting only if it is a DCS signal else not so condition is check the length of the signal
    ecg1 = circshift(ecg1,-750);
end
ecg1 = ecg1(1:size(dcs,2)*50);


% bp = 1:100:length(dcs);
% dcs_d = detrend(normalize(dcs),1,bp); 
% [dcs_1,filter_obj] = bandpass(dcs,[0.5 6],20,'ImpulseResponse','fir');
dcs_1 = dcs;
plot(dcs_1)
time_DCS=0.05*(1:1:size(dcs_1,2));
time_ECG=0.001*(1:1:size(ecg1,2));

figure()
hold on
plot(time_DCS,dcs_1/max(dcs_1),'r')
plot(time_ECG,ecg1/max(ecg1),'b')


% Find peaks
[pks_ECG,locs_ECG]=findpeaks(ecg1/max(ecg1),'MinPeakHeight',0.5);

locs_DCS_time=locs_DCS*0.05;
locs_ECG_time=locs_ECG*0.001;

time_shift1=locs_ECG_time(1)-locs_DCS_time(1) %% in s
% Upsampling the DCS singal
x = 1:1:length(dcs_1);
uf = 50;   % Upsampling factor
xq = (1:(1/uf):length(dcs_1)+((uf-1)/uf)); 
dcs_1_interp = interp1(x, dcs_1,xq,'makima');
% dcs_1_interp = dcs_1;


%
fig1=figure('units','centimeters', 'Position',[2 2 35 13]); %18 width 15 heigh
hold on
plot(dcs_1_smooth/max(dcs_1_smooth),'r')
plot(locs_DCS_smooth, pks_DCS_smooth,'*k')

plot(ecg1_smooth/max(ecg1_smooth),'b')
plot(locs_ECG_smooth, pks_ECG_smooth,'*k')

if locs_ECG_smooth(1)>locs_DCS_smooth(1)
    Difference=locs_ECG_smooth(1)-locs_DCS_smooth(1);
    shift = floor(1.75*Difference);
else
    shift =0;
end
% Extracting data

Extract=ones(size(pks_ECG_smooth,2)-3,min(diff(locs_ECG_smooth)));
Extract=Extract*NaN;

dcs_1_smooth2=circshift(dcs_1_smooth,00);

for i=2:size(pks_ECG_smooth,2)-2
    locs_ECG_smooth(i)
    locs_ECG_smooth(i)+min(diff(locs_ECG_smooth))
    signal = dcs_1_smooth2(locs_ECG_smooth(i):locs_ECG_smooth(i)+min(diff(locs_ECG_smooth))-1);
  
    for j=1:600
        temp(1,:,:)=mean(g2(1,floor((locs_ECG_smooth(i-2:i+2))/50),:));
    end

end

%% Smoothing the g2 curve with the moving average window for individual curve
g2_smooth = zeros(size(g2));
for i=1:size(g2,2)
    g2_smooth(1,i,:) = smooth(g2(1,i,:),5);
    g2_smooth(2,i,:) = smooth(g2(2,i,:),5);
    g2_smooth(3,i,:) = smooth(g2(3,i,:),5);
    g2_smooth(4,i,:) = smooth(g2(4,i,:),5);
    
end

%% Plotting g2 curves for whole signal
for i=1:5
    semilogx(Data_tau,squeeze(g2_smooth(4,i,:)));
    hold on;
end;
%%
for i=1:size(g2,1)
    Data_smooth(:,i,:) = g2(i,:,:);
end
%% 
aDb1_smooth = hybrid_dcs(Data_smooth,Data_tau);