% Checking the upsampling factor for the interp and interp1 functions, if
% it is linear or not
y = interp(dcs_1,50);
x = 1:length(y);
x_d = (1:length(dcs_1));
[pks_u,locs_u] = findpeaks(y, 'MinPeakHeight', 0.5,'MinPeakDist',600,'MinPeakProminence',0.1);  %Determine peaks and Indices
figure()
[pks_d,locs_d] = findpeaks(dcs_1, 'MinPeakHeight', 0.5,'MinPeakProminence',10);
[pks_u1,locs_u1] = findpeaks(dcs_1up, 'MinPeakHeight', 0.5,'MinPeakDist',600,'MinPeakProminence',0.1);
a = locs_u./locs_d;
b = locs_u1./locs_d;
plot(x_d,dcs_1)
hold on
plot(x_d(locs_d),pks_d, '+r')
hold off

%% 
dcs_1res = resample(dcs_1,50,1)
plot(dcs_1res)
hold on
plot(dcs_1up)

%%
xu = (1:1:length(ecg1))/1000;
xd = (1:1:length(dcs_1))/20;

%%
ecg_res = resample(ecg1,1,50)
te = (1:1:length(ecg_res));
plot(xd,ecg_res,'b')
legend("Resampled","Original")
hold on
plot(xu, ecg1,'r')
%%
ini = dcs_1(locs_d(1):locs_d(2));
cyc =zeros(length(pks)-1,length(ini)); 
cyc(1,:)= ini;
x = (1:1:length(ini))/1000;
count = 0;
avg = ini;
for i=1:1:length(locs_d)-1
    count = count+1;
 
    sig = dcs_1(find(xd==round(xu(locs(i)),1)):find(xd==round(xu(locs(i+1)),1)));
    hold on;
    if length(avg) > length(sig)
        sig(length(sig):length(avg)) = 0;
    elseif length(avg)< length(sig)
        sig = sig(1:length(avg));
    end
    avg = avg+sig;
    plot((1:length(sig))/20,sig, 'DisplayName',""+i+"");
%     legend show
    cyc(count,:) = sig;
        
end
xlabel("Time(s)")
ylabel("aDb value")
title("Marker=ECG R peak, DCS 1cm Baseline Forearm")
hold off
avg = avg/count;

figure()
plot(x,avg)

%Plotting the ensemble average
ensavg = mean(cyc,1);                                                   % Calculate Ensemble Average
ci95 = 1.96*std(cyc,[],1)/sqrt(count);                             % Calculate 95% Confidence Intervals         
figure()
plot(x, ensavg, '-r', 'LineWidth',1)
hold on;
plot(x, ensavg+ci95, ':g', 'LineWidth',1.5)
plot(x, ensavg-ci95, ':g', 'LineWidth',1.5)
hold off
grid
legend('Ensemble Average', '95% Confidence Intervals')

%%resampling

%%

figure()
hold on
plot(xd,dcs_1/max(dcs_1),'r')
plot(xd,ecg_res/max(ecg),'b')

%% Alligning the peaks of the DCS signal
% The idea is to coincide all the cycles by shifting the peaks to coincide
% with eachother to remove the temporal sh
Extract=ones(size(pks_ECG_smooth,2)-1,min(diff(locs_ECG_smooth)));
Extract=Extract*NaN;

dcs_1_smooth2=circshift(dcs_1_smooth,shift)

for i=1:size(pks_ECG_smooth,2)-1
    locs_ECG_smooth(i)
    locs_ECG_smooth(i)+min(diff(locs_ECG_smooth))
    signal = dcs_1_smooth2(1,locs_ECG_smooth(i):locs_ECG_smooth(i)+min(diff(locs_ECG_smooth))-1);
    base_sig = dcs_1_smooth2(1,locs_ECG_smooth(1):locs_ECG_smooth(1)+min(diff(locs_ECG_smooth))-1);
    sig = signal + (max(base_sig) - max(signal));
    [pks_b,locs_b] = findpeaks(base_sig, 'MinPeakHeight',0.2);
    [pks_s,locs_s] = findpeaks(sig, 'MinPeakHeight',0.2);
    if locs_b>=locs_s
        sig = shi
   
    if i==5
        break;
    end
    
%     Extract(i,:)=dcs_1_smooth2(1,locs_ECG_smooth(i):locs_ECG_smooth(i)+min(diff(locs_ECG_smooth))-1);

    Extract(i,:)=sig;
end
